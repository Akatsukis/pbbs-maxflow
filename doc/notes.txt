
Benchmark suite

Core Routines: (initial version completed)
  Sparse-Matrix Vector Multiply
     test on matrices with various degrees and separator sizes
  Radix-Sort
     test on 32-bit integers (skewed distribution)
  Hash-Table
     test to remove duplicates from a sequence of character strings
  Maximal-Independent-Set
     test on sparse graphs
  Maximal-matching
     test on sparse graphs
  Graph-coloring
     same test as MIS
  BFS
     test on shallow and deeper graphs
  Oct-Tree
     test inserting n points based on plummer model (dense in middle)
  Merging
    test on list of strings
  Scan
    test on FSA parser

Benchmarks: (initial version completed)
  Barnes-Hut n-body simulation
     test on skewed 3d mass distributions
  Delaunay triangulation
     test on variety of distributions
  K-nearest neighbors
     test on skewed 3d point distributions
  Suffix-Arrays (build a suffix array)
     test on large text corpus
  Edit-distance graph
     test on large text corpus
  Pagerank
     test on sample web graph
  Graph diameter
     test on sample web graph
  Graph separator
     test on grid graph and other graphs with reasonable separators

Benchmarks: (in progress or possible)
  Multiple sequence alignment (comp bio)
  K-means
  Graphical model for image segmentation
  SAT solver
  Others to be decided

Benchmark Goals:

 -- Designed to test a variety of algorithmic
paradigms---trees, graphs, text processing, sparse matrices---but with
an emphasis on irregular computations.

  -- Written using nested parallelism.  Currently they are written in 
C++ with Cilk++, but they are written so they don't use any Cilk++ 
specific features beyond spawn-synch and parallel for (i.e. they don't 
use reducers).  

 -- Designed to be reasonably easily ported among languages.   Each 
benchmark is therefore limited to 500 lines of code, and most are around 
200 lines.   There is very little use of language-specific libraries.

 -- All benchmarks are fully deterministic, or at least have the
option to run deterministically.  They are designed to 
return the same answer given any schedule.   Furthermore they are 
currently written so they are internally fully deterministic (modulo 
memory allocation).   

