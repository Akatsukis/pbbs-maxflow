#ifndef __SUFFIX_UTILS__
#define __SUFFIX_UTILS__
#include "hash2.h"
#include "stackSpace.h"

struct node { int firstChar; int parent; int value; };

struct suffixTree {
  typedef int nodeID;
  typedef int charType;
  typedef pair<nodeID,charType> hashKey;

  int n; // number of leaves (length of string)
  int m; // total number of nodes (leaves and internal)
  charType* S;
  node* Nodes;

  struct nodeHash {
    typedef nodeID eType;
    typedef hashKey kType;
    int n;
    charType* S;
    node* Nodes;
    eType empty() {return 0;}

    nodeHash(int _n, charType* _S, node *_Nodes) : 
      n(_n), S(_S), Nodes(_Nodes) {}

    inline nodeID parent(nodeID node) { return Nodes[node].parent;}
    inline int value(nodeID node) { return Nodes[node].value;}
    inline int start(nodeID node) {
      if (node & 1 == 1) return n - value(node)+1;
      else return n - value(node-1)+1;
    }
    inline int length(nodeID node) {return value(node)-value(parent(node));}
    inline int offset(nodeID node) {return start(node) + value(parent(node)); }
    //inline charType firstChar(nodeID node) { return S[offset(node)]; }
    inline charType firstChar(nodeID node) { return Nodes[node].firstChar; }

    kType getKey(eType v) { return kType(parent(v),firstChar(v));}

    unsigned int hash(kType key) {
      unsigned int seed = utils::hash(key.first);
      seed ^= utils::hash(key.second) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
      return seed;
    }

    int cmp(kType a, kType b) {
      if (a.first > b.first) return 1;
      else if (a.first < b.first) return -1;
      else return ((a.second > b.second) ? 1 : 
		   ((a.second == b.second) ? 0 : -1));
    }
    
    bool replaceQ(eType a, eType b) { return false;}
  };

  typedef Table<nodeHash> nodeHashTable;

  nodeHashTable *table;

  struct toInt { int operator() (bool a) {return (int) a;}};

  #define NEAR 16

  void addToHashTable(int* space, int size) {
    bool* FL = newA(bool,m);
    cilk_for (int i=1; i < m; i++) {
      Nodes[i].firstChar = S[offset(i)]; 
      nodeID p = Nodes[i].parent;
      FL[i] = (Nodes[p].value < Nodes[i].value && abs(i-p) > NEAR);
    }
    int l = sequence::mapReduce<int>(FL,m,utils::addF<int>(),toInt());
    //cout << "l=" << l << endl;
    table = new nodeHashTable(2*l, nodeHash(n,S,Nodes), space, size);
    cilk_for (int i=1; i < m; i++) {
      if (FL[i]) table->insert(i);
    }
    free(FL);
  }

  suffixTree(int _n, int _m, node* _nodes, charType* _s, 
	     int* space, int size) :
    n(_n), m(_m), Nodes(_nodes), S(_s)
  {
    addToHashTable(space, size);
  }

  suffixTree() {};

  void del() {
    table->del();
    //free(Nodes);
  }

  inline nodeID parent(nodeID node) { return Nodes[node].parent;}
  inline int value(nodeID node) { return Nodes[node].value;}
  inline int start(nodeID node) {
    if (node & 1 == 1) return n - value(node)+1;
    else return n - value(node-1)+1;
  }
  inline int length(nodeID node) {return value(node)-value(parent(node));}
  inline int offset(nodeID node) {return start(node) + value(parent(node)); }
  inline charType firstChar(nodeID node) { return Nodes[node].firstChar; }
  //inline charType firstChar(nodeID node) { return S[offset(node)]; }

  nodeID searchNear(hashKey K) {
    nodeID i = K.first;
    charType c = K.second;
    for (int j = 1; j <= NEAR; j++) {
      if (i-j > 0 && parent(i-j) == i && firstChar(i-j) == c) return i-j;
      if (i+j < m && parent(i+j) == i && firstChar(i+j) == c) return i+j;
    }
    return 0;
  }

  int search(int* string) {
    int position = 0;
    nodeID currentNode = 0;  
    if (string[0] == 0) return 0;

    while (1) {
      hashKey k = hashKey(currentNode,string[position]);
      currentNode = table->find(k);
      if (currentNode == 0) {
	currentNode = searchNear(k);
	if (currentNode == 0) return -1;
      } 
      int len = length(currentNode);
      int off = offset(currentNode);

      // don't need to test first position since matched in hash table
      for (int i=1; i < len; i++) {
	if (string[position+i] == 0) return off-position;
	if (string[position+i] != S[off+i]) return -1;
      }

      if (string[position+len] == 0) return off-position;
      position += len;
    }
  }
};

suffixTree suffixArrayToTree (int* SA, int* LCP, int n, int* s, stackSpace* stack);
pair<int*,int*> suffixArray(int* s, int n, bool findLCPs, stackSpace* stack);

#endif
