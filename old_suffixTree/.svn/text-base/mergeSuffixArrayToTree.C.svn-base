#include <iostream>
#include "gettime.h"
#include "intSort.h"
#include "sequence.h"
#include "utils.h"
#include "suffixTree.h"
#include "stackSpace.h"
#include "cartesianTree.h"
#include "cartesianTreeNode.h"

using namespace std;
#define CHECK 0

void cartesianTreeStack(node_c* Nodes, int n);

inline int getRoot(node* nodes, int i) {
  int root = nodes[i].parent;
  while (root != 0 && nodes[nodes[root].parent].value == nodes[root].value)
    root = nodes[root].parent;
  return root;
}

// NOT CURRENTLY USED (NOR CHECKED FOR CORRECTNESS)
int filterClusterRoots(node* nodes, node* out, int m) {
  int* nums = new int[m];
  nums[0] = 1;
  cilk_for(int i = 1; i < m; i++){
    int p = nodes[i].parent;
    nums[i] = (nodes[i].value > nodes[p].value);
    nodes[i].parent = getRoot(nodes, i);
  }  
  int l = sequence::scan(nums, nums, m, utils::addF<int>(), 0);

  out = new node[l];
  // should be cilk_for, but broken
  for(int i = 0; i < m; i++){
    int e = (i == m-1) ? l : nums[i+1];
    if (nums[i] < e) {
      out[nums[i]].value = nodes[i].value;
      out[nums[i]].parent = nums[nodes[i].parent];
    }
  }
  free(nums);
  return l;
}

suffixTree suffixArrayToTree (int* SA, int* LCP, int n, int* s, stackSpace* stack){
  startTime();
  if (0) {
  node_c* test = new node_c[2*n];
  cilk_for(int i=1; i<n; i++){ //internal
    test[2*i].value = LCP[i-1];
    test[2*i+1].value = n-SA[i]+1;
    test[2*i].rightChild = test[2*i+1].rightChild = 
      test[2*i].parent = test[2*i+1].parent = -1;
  }
  test[0].value = 0;
  test[1].value = n-SA[0]+1;
  test[0].parent = test[1].parent = -1;
  
  nextTime("Time to initialize nodes for sequential CT (subtract off)");
  cartesianTreeStack(test+1,2*n-1);
  nextTime("Time for stack-based sequential CT construction (subtract off)");
  }

  startTime();
  int m = 2*n;

  //initialize nodes
  node* nodes = (node*) stack->push(sizeof(node)*m);
  cilk_for(int i=1; i<n; i++){ 
    nodes[2*i].value = LCP[i-1];
    nodes[2*i+1].value = n-SA[i]+1; // length of string including 1 past end
    nodes[2*i].parent = 0;
    nodes[2*i+1].parent = 0;
  }
  nodes[0].value = 0;
  nodes[1].value = n-SA[0]+1;
  nodes[0].parent = nodes[1].parent = 0;
  nextTime("Time to initialize nodes");

  cartesianTree(nodes, 1, m-1);
  nextTime("Time for building CT in parallel");

  // shortcut to roots of each cluster
  cilk_for(int i = 1; i < m; i++) 
    nodes[i].parent = getRoot(nodes, i);
  nextTime("Time for shortcuts");

  // insert into hash table
  
  suffixTree ST = suffixTree(n, m, nodes, s, (int*) stack->ith(2), 2*n);
  nextTime("Time for inserting into hash table");

  return ST;
}
